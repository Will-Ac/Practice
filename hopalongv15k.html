<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width,initial-scale=1,viewport-fit=cover" name="viewport"/>
<title>Hopalong</title>
<style>
    :root { color-scheme: dark; }
    html, body { height: 100%; margin: 0; background: #000; }
    canvas { width: 100%; height: 100%; display: block; touch-action: none; -webkit-user-select:none; user-select:none; -webkit-touch-callout:none; }

    #backdrop {
      position: fixed; inset: 0;
      background: rgba(0,0,0,0.0);
      display: none;
      z-index: 9;
      touch-action: none;
    }

    #menu {
      position: fixed;
      top: 12px;
      right: 12px;
      bottom: 12px;
      left: auto;
      width: min(34vw, 520px);
      min-width: 340px;
      border: 1px solid rgba(255,255,255,.18);
      border-radius: 16px;
      background: rgba(16,16,16,.92);
      color: #fff;
      padding: 14px 14px 10px 14px;
      display: none;
      overflow: auto;
      -webkit-overflow-scrolling: touch;
      -webkit-backdrop-filter: blur(10px);
      backdrop-filter: blur(10px);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      z-index: 10;
      -webkit-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
    }

    @media (max-width: 720px){
      #menu{
        width: 92vw;
        min-width: 0;
        right: 12px;
        left: 12px;
      }
    }

    #menuTop {
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
      position: sticky;
      top: 0;
      padding: 4px 0 10px 0;
      background: rgba(16,16,16,.92);
      z-index: 11;
    }
    #menuTop h2 { margin: 0; font-size: 16px; font-weight: 800; }
    #menuBtns { display: flex; gap: 10px; align-items: center; }
    button {
      border: 1px solid rgba(255,255,255,.25);
      background: rgba(255,255,255,.08);
      color: #fff;
      padding: 10px 12px;
      border-radius: 12px;
      font-weight: 700;
    }

    .row {
      display: grid;
      grid-template-columns: 26px 140px 1fr 80px;
      gap: 10px;
      align-items: center;
      padding: 8px 0;
      border-bottom: 1px solid rgba(255,255,255,.08);
    }
    .row:last-child { border-bottom: none; }
    .row label { opacity: .9; }
    .row output { text-align: right; font-variant-numeric: tabular-nums; opacity: .95; }
    input[type="range"], select { width: 100%; }

    .cmPreview {
      height: 12px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.18);
      background: linear-gradient(90deg, #000, #fff);
    }
    .subnote { font-size: 12px; opacity: .75; margin-top: 10px; line-height: 1.35; }
    code { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
  
    #renderInfo{
      -webkit-user-select:none; user-select:none; -webkit-touch-callout:none;
      position: fixed;
      display: none; /* hidden for clean screen */
      left: 12px;
      right: 170px; /* leave room for view pad */
      bottom: 12px;
      max-width: 720px;
      max-height: 18vh; /* smaller */
      overflow: auto;
      -webkit-overflow-scrolling: touch;
      border: 1px solid rgba(255,255,255,.16);
      border-radius: 14px;
      background: rgba(16,16,16,.70);
      color: #fff;
      padding: 8px 10px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      z-index: 8;
      -webkit-backdrop-filter: blur(8px);
      backdrop-filter: blur(8px);
      pointer-events: auto;
    }
    #renderInfo .riEntry{
      border-top: 1px solid rgba(255,255,255,.10);
      padding: 8px 8px;
      margin: 0;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
    }
    #renderInfo .riEntry:first-child{ border-top: none; padding-top: 0; margin-top: 0; }
    #renderInfo .riHdr{
      display:flex;
      justify-content: space-between;
      gap: 10px;
      font-size: 12px;
      line-height: 1.2;
      margin-bottom: 2px;
    }
    #renderInfo .riHdr b{ font-size: 13px; }
    #renderInfo .riHdr span{ font-size: 12px; opacity:.75; }
    #renderInfo .riGrid{
      display: grid;
      grid-template-columns: 92px 1fr;
      gap: 4px 10px;
      margin-top: 6px;
      font-size: 12px;
      line-height: 1.25;
    }
    #renderInfo .riKey{ font-size: 12px; opacity: .78; }
    #renderInfo .riVal{ font-size: 12px; font-variant-numeric: tabular-nums; }
    #renderInfo .riVal code{ font-size: 11px; }
    
    #renderInfo .riEntry{
      border-top: 1px solid rgba(255,255,255,.10);
      padding: 8px 8px;
      margin: 0;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
    }
    #renderInfo .riEntry:hover{ background: rgba(255,255,255,.04); border-radius: 12px; padding: 10px 8px; margin-left:-4px; margin-right:-4px; }
    #renderInfo .riEntry:active{ background: rgba(255,255,255,.07); }
    #renderInfo .riEntry.selected{ outline: 1px solid rgba(255,255,255,.28); border-radius: 12px; padding: 10px 8px; margin-left:-4px; margin-right:-4px; }
    #renderInfo .riHdr b{ font-size: 12px; }
    #renderInfo .riHdr span{ font-size: 11px; opacity:.75; }
    #renderInfo .riGrid{
      display: grid;
      grid-template-columns: 92px 1fr;
      gap: 4px 10px;
      margin-top: 6px;
      font-size: 12px;
      line-height: 1.25;
    }

    #renderInfo .riCmapBar{
      height: 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.18);
      margin-top: 4px;
    }

  
    #viewControls{
      position: fixed;
      display: none; /* shown on long-press */
      right: 12px;
      bottom: 12px;
      z-index: 9;
      display: grid;
      grid-template-columns: 64px 64px 64px;
      grid-template-rows: 64px 64px 64px 64px;
      gap: 10px;
      padding: 14px;              /* dead-zone padding */
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(16,16,16,.78);
      -webkit-backdrop-filter: blur(10px);
      backdrop-filter: blur(10px);
      touch-action: manipulation;
      pointer-events: auto;        /* intercept taps even if you miss the buttons */
    }
    #viewControls button{
      width: 64px; height: 64px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.06);
      color: #fff;
      font-size: 22px;
      font-weight: 700;
      line-height: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }
    #viewControls button:active{ background: rgba(255,255,255,.10); }
    #viewControls .vcEmpty{ visibility:hidden; }

  
    #installHint{
      position: fixed;
      top: 12px;
      left: 50%;
      transform: translateX(-50%);
      max-width: min(720px, calc(100vw - 24px));
      background: rgba(16,16,16,.86);
      border: 1px solid rgba(255,255,255,.18);
      border-radius: 14px;
      padding: 10px 12px;
      color: #fff;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      z-index: 12;
      display: none;
      -webkit-backdrop-filter: blur(10px);
      backdrop-filter: blur(10px);
    }
    #installHint .row{
      display:flex;
      gap:10px;
      align-items:flex-start;
      border: none;
      padding: 0;
      grid-template-columns: none;
    }
    #installHint b{ font-size: 13px; }
    #installHint p{ margin: 2px 0 0 0; font-size: 12px; opacity: .85; line-height: 1.25; }
    #installHint button{
      padding: 8px 10px;
      border-radius: 12px;
      font-size: 12px;
      white-space: nowrap;
    }

  
    /* --- V15b: prevent iOS/Safari text selection/callout on canvas + overlays --- */
    body, canvas, #viewControls, #renderInfo, #installHint, #backdrop {
      -webkit-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
      -webkit-tap-highlight-color: transparent;
    }
    /* Allow normal interaction inside the settings menu */
    #menu { -webkit-user-select: text; user-select: text; -webkit-touch-callout: default; }
    #menu input, #menu button, #menu select { -webkit-user-select: none; user-select: none; -webkit-touch-callout: none; }


  .randFlag{margin-left:8px; transform:scale(1.2); vertical-align:middle;}
  @media (hover:none){ .randFlag{transform:scale(1.35);} }

    /* --- iOS: hard-disable text selection/callouts inside menu --- */
    #menu, #menu * {
      -webkit-user-select: none !important;
      user-select: none !important;
      -webkit-touch-callout: none !important;
      -webkit-tap-highlight-color: transparent;
    }
    /* Make sliders reliably draggable on iOS (avoid scroll stealing horizontal drags) */
    #menu input[type="range"]{
      touch-action: pan-x;
    }
    #menu.noScroll{
      overflow: hidden !important;
    }

</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="installHint"><div class="row"><div><b>Install for full‑screen</b><p>Share → Add to Home Screen (keep “Open as Web App” on) for the cleanest full‑screen experience.</p></div><div style="margin-left:auto; display:flex; gap:8px;"><button id="btnInstallDismiss" type="button">Dismiss</button></div></div></div>
<div aria-live="polite" id="renderInfo"></div>
<div id="backdrop"></div>
<div id="menu">
<div id="menuTop">
<h2>Hopalong (dual randomize)</h2>
<div id="menuBtns">
<button id="btnApply">Apply + Draw</button>
<button id="btnClose">Close</button>
</div>
</div>

<!-- hidden legacy toggle (always on) -->
<input id="randomize" type="checkbox" checked style="display:none"/>
<output id="randomizeOut" style="display:none">ON</output>
<output id="randModeOut" style="display:none">All params</output>

<div class="row">
<input checked class="randFlag" id="rand_formula" type="checkbox" title="Randomize this parameter"/>
<label for="formula">Formula</label>
<div style="display:flex; flex-direction:column; gap:6px;">
  <select id="formula"></select>
  <div id="formulaDesc" style="font-size:12px; opacity:.8"></div>
</div>
<output id="formulaOut">Classic (sqrt)</output>
</div>

<div class="row">
<input checked class="randFlag" id="rand_alpha" type="checkbox" title="Randomize this parameter"/>
<label for="alpha">α (alpha)</label>
<input id="alpha" type="range" min="-100" max="100" step="0.001" value="1.0"/>
<output id="alphaOut">1.000000</output>
</div>

<div class="row">
<input checked class="randFlag" id="rand_beta" type="checkbox" title="Randomize this parameter"/>
<label for="beta">β (beta)</label>
<input id="beta" type="range" min="-100" max="100" step="0.001" value="19.0"/>
<output id="betaOut">19.000000</output>
</div>

<div class="row">
<input checked class="randFlag" id="rand_gamma" type="checkbox" title="Randomize this parameter"/>
<label for="gamma">γ (gamma)</label>
<input id="gamma" type="range" min="-5" max="5" step="0.001" value="0.0"/>
<output id="gammaOut">0.000000</output>
</div>

<div class="row">
<input checked class="randFlag" id="rand_delta" type="checkbox" title="Randomize this parameter"/>
<label>δ (delta)</label>
<div style="display:flex; gap:10px; align-items:center;">
  <label style="display:flex; gap:6px; align-items:center;"><input checked name="delta" type="radio" value="0"/>0</label>
  <label style="display:flex; gap:6px; align-items:center;"><input name="delta" type="radio" value="1"/>1</label>
</div>
<output id="deltaOut">0</output>
</div>

<div class="row">
<input checked class="randFlag" id="rand_orbits" type="checkbox" title="Randomize this parameter"/>
<label for="orbits">Orbits (N)</label>
<input id="orbits" type="range" min="1" max="80" step="1" value="25"/>
<output id="orbitsOut">25</output>
</div>

<div class="row">
<input checked class="randFlag" id="rand_iters" type="checkbox" title="Randomize this parameter"/>
<label for="iters">Iters</label>
<input id="iters" type="range" min="500" max="50000" step="100" value="8000"/>
<output id="itersOut">8000</output>
</div>

<div class="row">
<input checked class="randFlag" id="rand_burn" type="checkbox" title="Randomize this parameter"/>
<label for="burn">Burn-in</label>
<input id="burn" type="range" min="0" max="5000" step="5" value="50"/>
<output id="burnOut">50</output>
</div>

<div class="row">
<input checked class="randFlag" id="rand_rangeR" type="checkbox" title="Randomize this parameter"/>
<label for="rangeR">Range r</label>
<input id="rangeR" type="range" min="20" max="2000" step="1" value="300"/>
<output id="rangeROut">300</output>
</div>

<div class="row">
<input checked class="randFlag" id="rand_initR" type="checkbox" title="Randomize this parameter"/>
<label for="initR">Init range</label>
<input id="initR" type="range" min="10" max="300" step="1" value="100"/>
<output id="initROut">100</output>
</div>

<div class="row">
<input checked class="randFlag" id="rand_cmap" type="checkbox" title="Randomize this parameter"/>
<label for="cmap">Color map</label>
<div style="display:flex; flex-direction:column; gap:6px;">
  <select id="cmap"></select>
  <div class="cmPreview" id="cmPreview"></div>
</div>
<output id="cmapOut">Turbo</output>
</div>

<div class="subnote">
Gestures:
<br/>• Short tap (menu hidden): <b>redraw</b>
<br/>• Long press (~0.5s): <b>open menu</b>
<br/>• Menu open: <b>tap outside</b> closes + draws
<br/><br/>
Randomize:
<br/>• Tick the checkbox next to any parameter you want randomized on each redraw.
</div>
</div>
<script>
(() => {
  // ---------- canvas / pixel buffer ----------
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: false });
  let img, buf;

  // View-only adjustments for the *last* completed render (no parameter changes)
  let viewZoom = 1.0;
  let viewPanX = 0.0; // world units
  let viewPanY = 0.0; // world units

  // Stored points/colors from the last completed render
  let lastPtsXY = null;         // Float32Array of [x0,y0,x1,y1,...] in world coords
  let lastPtOrbit = null;       // Uint16Array orbit index per point
  let lastPtCount = 0;          // number of points
  let lastOrbitColors = null;   // array of [r,g,b] per orbit
  let lastBaseR = 0;            // r used for mapping


  function resize() {
    const dpr = window.devicePixelRatio || 1;
    canvas.width  = Math.floor(window.innerWidth  * dpr);
    canvas.height = Math.floor(window.innerHeight * dpr);
    ctx.imageSmoothingEnabled = false;
    img = ctx.createImageData(canvas.width, canvas.height);
    buf = img.data;
    clearScreen();
  }
  window.addEventListener('resize', resize, { passive: true });

  function clearScreen() {
    for (let i = 0; i < buf.length; i += 4) {
      buf[i] = 0; buf[i+1] = 0; buf[i+2] = 0; buf[i+3] = 255;
    }
    ctx.putImageData(img, 0, 0);
  }
  resize();
  attachViewControls();

  function setPixel(x, y, r, g, b) {
    const idx = (y * canvas.width + x) * 4;
    buf[idx] = r; buf[idx+1] = g; buf[idx+2] = b; buf[idx+3] = 255;
  }
  function resetView() {
    viewZoom = 1.0;
    viewPanX = 0.0;
    viewPanY = 0.0;
  }

  function redrawLastRender() {
    if (!lastPtsXY || !lastPtOrbit || !lastOrbitColors || lastPtCount <= 0) return;

    const w = canvas.width, h = canvas.height;
    const r = lastBaseR;

    const sx = ((w - 1) / (2 * r)) * viewZoom;
    const sy = ((h - 1) / (2 * r)) * viewZoom;
    const xoff = r;
    const yoff = r;

    // clear buffer
    for (let i = 0; i < buf.length; i += 4) {
      buf[i] = 0; buf[i+1] = 0; buf[i+2] = 0; buf[i+3] = 255;
    }

    for (let i = 0; i < lastPtCount; i++) {
      const x = lastPtsXY[i*2]     - viewPanX;
      const y = lastPtsXY[i*2 + 1] - viewPanY;
      const px = ((x + xoff) * sx) | 0;
      const py = ((yoff - y) * sy) | 0;

      if ((px >>> 0) < w && (py >>> 0) < h) {
        const c = lastOrbitColors[lastPtOrbit[i]];
        setPixel(px, py, c[0], c[1], c[2]);
      }
    }

    ctx.putImageData(img, 0, 0);
  }

  function attachViewControls() {
    const plus  = document.getElementById('vcPlus');
    const minus = document.getElementById('vcMinus');
    const up    = document.getElementById('vcUp');
    const down  = document.getElementById('vcDown');
    const left  = document.getElementById('vcLeft');
    const right = document.getElementById('vcRight');
    const reset = document.getElementById('vcReset');
    const menuBtn = document.getElementById('vcMenu');
    const hideBtn = document.getElementById('vcHide');
    const box   = document.getElementById('viewControls');
    if (box){
      const swallow = (ev) => { ev.stopPropagation(); ev.preventDefault(); };
      box.addEventListener('pointerdown', swallow, { passive: false });
      box.addEventListener('pointerup', swallow, { passive: false });
      box.addEventListener('click', swallow, { passive: false });
      box.addEventListener('touchstart', swallow, { passive: false });
      box.addEventListener('touchend', swallow, { passive: false });
    }

    const clickish = (el, fn) => {
      if (!el) return;
      const handler = (ev) => { ev.preventDefault(); ev.stopPropagation(); if (drawing) return; fn(); };
      el.addEventListener('click', handler, { passive: false });
      el.addEventListener('touchstart', handler, { passive: false });
    };

    clickish(plus, () => { viewZoom *= 1.20; redrawLastRender(); });
    clickish(minus, () => { viewZoom /= 1.20; redrawLastRender(); });

    const panStep = () => (lastBaseR ? (lastBaseR * 0.12) / viewZoom : 10);

    clickish(left,  () => { viewPanX -= panStep(); redrawLastRender(); });
    clickish(right, () => { viewPanX += panStep(); redrawLastRender(); });
    clickish(up,    () => { viewPanY += panStep(); redrawLastRender(); });
    clickish(down,  () => { viewPanY -= panStep(); redrawLastRender(); });

    clickish(reset, () => { resetView(); redrawLastRender(); });
    // Menu and hide
    clickish(menuBtn, () => { showMenu(true); });
    clickish(hideBtn, () => { showControls(false); });

  }


  // ---------- UI / menu ----------
  const menu = document.getElementById('menu');
  const backdrop = document.getElementById('backdrop');
  const btnApply = document.getElementById('btnApply');
  const btnClose = document.getElementById('btnClose');

  const elFormula = document.getElementById('formula');
  const elFormulaDesc = document.getElementById('formulaDesc');
  const outFormula = document.getElementById('formulaOut');

  const elRandModeOut = document.getElementById('randModeOut');
  const randModeRadios = Array.from(document.querySelectorAll('input[name="randMode"]'));

  const elRandomize = document.getElementById('randomize');
  const elAlpha = document.getElementById('alpha');
  const elBeta = document.getElementById('beta');
  const elGamma = document.getElementById('gamma');
  const elOrbits = document.getElementById('orbits');
  const elIters = document.getElementById('iters');
  const elBurn = document.getElementById('burn');
  const elRangeR = document.getElementById('rangeR');
  const elInitR = document.getElementById('initR');
  const elCmap = document.getElementById('cmap');
  // per-parameter randomize flags (default checked)
  const rand = {
    formula: document.getElementById('rand_formula'),
    cmap: document.getElementById('rand_cmap'),
    alpha: document.getElementById('rand_alpha'),
    beta: document.getElementById('rand_beta'),
    gamma: document.getElementById('rand_gamma'),
    delta: document.getElementById('rand_delta'),
    orbits: document.getElementById('rand_orbits'),
    iters: document.getElementById('rand_iters'),
    burn: document.getElementById('rand_burn'),
    rangeR: document.getElementById('rand_rangeR'),
    initR: document.getElementById('rand_initR')
  };
  const cmPreview = document.getElementById('cmPreview');

  const outRandomize = document.getElementById('randomizeOut');
  const outAlpha = document.getElementById('alphaOut');
  const outBeta = document.getElementById('betaOut');
  const outGamma = document.getElementById('gammaOut');
  const outDelta = document.getElementById('deltaOut');
  const outOrbits = document.getElementById('orbitsOut');
  const outIters = document.getElementById('itersOut');
  const outBurn = document.getElementById('burnOut');
  const outRangeR = document.getElementById('rangeROut');
  const outInitR = document.getElementById('initROut');
  const outCmap = document.getElementById('cmapOut');

  const deltaRadios = Array.from(document.querySelectorAll('input[name="delta"]'));
  function getDelta() {
    const r = deltaRadios.find(x => x.checked);
    return r ? parseInt(r.value, 10) : 0;
  }

  function getRandMode() {
    const r = randModeRadios.find(x => x.checked);
    return r ? r.value : "ab";
  }

  // ---------- colormaps ----------
  function clamp01(x){ return x < 0 ? 0 : (x > 1 ? 1 : x); }
  function lerp(a,b,t){ return a + (b-a)*t; }
  function lerp3(c1,c2,t){ return [lerp(c1[0],c2[0],t), lerp(c1[1],c2[1],t), lerp(c1[2],c2[2],t)]; }
  function fromStops(stops, t){
    t = clamp01(t);
    for (let i=0; i<stops.length-1; i++){
      const a = stops[i], b = stops[i+1];
      if (t >= a[0] && t <= b[0]){
        const u = (t - a[0]) / (b[0] - a[0] || 1);
        return lerp3(a[1], b[1], u);
      }
    }
    return stops[stops.length-1][1];
  }

  const ColorMaps = {
    "Turbo": (t) => fromStops([
      [0.00,[48,18,59]],[0.10,[50,44,125]],[0.20,[32,96,189]],[0.30,[41,158,179]],
      [0.40,[93,201,99]],[0.50,[177,222,44]],[0.60,[236,199,24]],[0.70,[250,144,25]],
      [0.80,[243,85,38]],[0.90,[206,41,57]],[1.00,[122,4,3]]
    ], t),
    "Viridis": (t) => fromStops([[0,[68,1,84]],[.25,[59,82,139]],[.5,[33,145,140]],[.75,[94,201,98]],[1,[253,231,37]]], t),
    "Plasma": (t) => fromStops([[0,[13,8,135]],[.25,[126,3,167]],[.5,[203,71,119]],[.75,[248,149,64]],[1,[240,249,33]]], t),
    "Inferno": (t) => fromStops([[0,[0,0,4]],[.25,[87,15,109]],[.5,[187,55,84]],[.75,[249,142,8]],[1,[252,255,164]]], t),
    "Magma": (t) => fromStops([[0,[0,0,4]],[.25,[78,18,123]],[.5,[182,54,121]],[.75,[251,136,97]],[1,[252,253,191]]], t),
    "Gray": (t) => { const v = Math.round(255*clamp01(t)); return [v,v,v]; },
    "Rainbow": (t) => {
      t = clamp01(t);
      const h = (1 - t) * 240;
      const c = 1, hp = h/60, x = c*(1-Math.abs((hp%2)-1));
      let r=0,g=0,b=0;
      if (hp<1){ r=c; g=x; } else if (hp<2){ r=x; g=c; }
      else if (hp<3){ g=c; b=x; } else if (hp<4){ g=x; b=c; }
      else if (hp<5){ r=x; b=c; } else { r=c; b=x; }
      return [Math.round(r*255),Math.round(g*255),Math.round(b*255)];
    },
    "Heat": (t) => fromStops([[0,[0,0,0]],[.33,[180,0,0]],[.66,[255,160,0]],[1,[255,255,255]]], t),
    "Ocean": (t) => fromStops([[0,[0,0,0]],[.25,[0,20,70]],[.5,[0,90,160]],[.75,[40,180,220]],[1,[220,250,255]]], t)
  
    ,
    "H&E": (t) => fromStops([[0,[20,10,30]],[.20,[60,40,120]],[.45,[190,90,180]],[.70,[245,170,210]],[1,[255,245,250]]], t),
    "Giemsa": (t) => fromStops([[0,[10,8,30]],[.25,[30,60,140]],[.50,[80,140,170]],[.75,[210,180,120]],[1,[250,245,220]]], t),
    "Gram": (t) => fromStops([[0,[15,10,20]],[.30,[90,40,140]],[.55,[160,90,210]],[.78,[210,160,80]],[1,[245,245,235]]], t),
    "PAS": (t) => fromStops([[0,[15,8,8]],[.28,[120,30,70]],[.55,[220,120,160]],[.78,[245,210,120]],[1,[255,250,235]]], t),
    "Trichrome": (t) => fromStops([[0,[5,20,30]],[.25,[10,70,120]],[.50,[40,140,160]],[.75,[170,190,120]],[1,[245,245,230]]], t),
    "DAB": (t) => fromStops([[0,[5,5,5]],[.25,[60,40,20]],[.50,[120,80,40]],[.75,[190,150,90]],[1,[250,245,235]]], t),
    "Fluorescein": (t) => fromStops([[0,[0,0,0]],[.15,[0,30,10]],[.40,[0,120,40]],[.70,[60,220,90]],[1,[230,255,240]]], t),
    "Toluidine": (t) => fromStops([[0,[5,5,20]],[.25,[30,30,110]],[.50,[80,90,190]],[.75,[150,170,220]],[1,[245,250,255]]], t),
    "Safranin+FG": (t) => fromStops([[0,[10,5,5]],[.25,[160,40,60]],[.50,[220,120,90]],[.72,[80,160,90]],[1,[235,250,235]]], t),
    "Sepia": (t) => fromStops([[0,[0,0,0]],[.25,[70,50,30]],[.50,[130,100,60]],[.75,[200,175,130]],[1,[250,245,235]]], t)
};

  // ---------- render info panel ----------
const renderInfo = document.getElementById('renderInfo');
renderInfo.addEventListener('pointerdown', (ev)=>{ ev.stopPropagation(); }, { passive: true });
renderInfo.addEventListener('pointerup', (ev)=>{ ev.stopPropagation(); }, { passive: true });
renderInfo.addEventListener('click', (ev)=>{ ev.stopPropagation(); }, { passive: true });
renderInfo.addEventListener('touchstart', (ev)=>{ ev.stopPropagation(); }, { passive: true });
renderInfo.addEventListener('touchend', (ev)=>{ ev.stopPropagation(); }, { passive: true });


const HISTORY_KEY = "hopalong_render_history_v1";
const MAX_HISTORY = 50;

let renderCount = 0;
let lastRender = null;
let renderHistory = [];

function loadHistory(){
  try{
    const raw = localStorage.getItem(HISTORY_KEY);
    if (!raw) return;
    const arr = JSON.parse(raw);
    if (Array.isArray(arr)) renderHistory = arr.slice(0, MAX_HISTORY);
    if (renderHistory.length) {
      lastRender = renderHistory[0];
      // keep renderCount monotonic if possible
      const mx = renderHistory.reduce((acc,p)=>Math.max(acc, p._id||0), 0);
      renderCount = Math.max(renderCount, mx);
    }
  }catch(_){}
}

function saveHistory(){
  try{
    localStorage.setItem(HISTORY_KEY, JSON.stringify(renderHistory.slice(0, MAX_HISTORY)));
  }catch(_){}
}

function nowStamp(){
  const d = new Date();
  return d.toLocaleString(undefined, { year:'numeric', month:'2-digit', day:'2-digit', hour:'2-digit', minute:'2-digit', second:'2-digit' });
}

function fmtNum(x, digits=6){
  return (Number.isFinite(x) ? (+x).toFixed(digits) : String(x));
}

function cmapGradientCSS(name){
  const cmap = ColorMaps[name] || ColorMaps['Turbo'];
  const stops = [];
  for (let i=0;i<=10;i++){
    const t=i/10;
    const c=cmap(t);
    stops.push(`rgb(${c[0]|0},${c[1]|0},${c[2]|0}) ${Math.round(t*100)}%`);
  }
  return `linear-gradient(90deg, ${stops.join(',')})`;
}

function applyParamsToUI(p){
  // Formula
  if (p.formulaId) elFormula.value = p.formulaId;

  // Randomize
  if (typeof p.autoRandomizeRaw === "boolean") elRandomize.checked = p.autoRandomizeRaw;

  // Rand mode
  if (p.randModeRaw) setRandMode(p.randModeRaw);

  // Params
  if (p.alpha != null) elAlpha.value = String(p.alpha);
  if (p.beta  != null) elBeta.value  = String(p.beta);
  if (p.gamma != null) elGamma.value = String(p.gamma);

  // Delta
  if (p.delta != null) setDelta(parseInt(p.delta, 10) || 0);

  // Counts/ranges
  if (p.N != null)     elOrbits.value = String(p.N);
  if (p.iters != null) elIters.value  = String(p.iters);
  if (p.burn != null)  elBurn.value   = String(p.burn);
  if (p.rangeR != null) elRangeR.value = String(p.rangeR);
  if (p.initR  != null) elInitR.value  = String(p.initR);

  // Colormap
  if (p.cmap) elCmap.value = p.cmap;

  syncUI();
}

function renderHistoryUI(selectedId=null){
  renderInfo.innerHTML = "";

  if (!renderHistory.length){
    renderInfo.innerHTML = '<div style="opacity:.75; font-size:12px;">No renders yet. Tap canvas to draw. Long-press to open menu.</div>';
    return;
  }

  for (const p of renderHistory){
    const e = document.createElement('div');
    e.className = 'riEntry' + ((selectedId && p._id === selectedId) ? ' selected' : '');
    e.dataset.rid = String(p._id || 0);

    const status = p.completed ? 'complete' : 'aborted';

    e.innerHTML = `
      <div class="riHdr">
        <b>Render #${p._id || ""} — ${status}</b>
        <span>${p.when || ""}</span>
      </div>
      <div class="riGrid">
        <div class="riKey">Formula</div>
        <div class="riVal"><b>${p.formulaName || ""}</b> <span style="opacity:.75">(${p.formulaId || ""})</span><br><code>${p.formulaDesc || ""}</code></div>

        <div class="riKey">Parameters</div>
        <div class="riVal">α=${fmtNum(+p.alpha)}, β=${fmtNum(+p.beta)}, γ=${fmtNum(+p.gamma)}, δ=${String(p.delta)}</div>

        <div class="riKey">Orbits / iters</div>
        <div class="riVal">N=${String(p.N)}, iters=${String(p.iters)}, burn=${String(p.burn)}</div>

        <div class="riKey">Ranges</div>
        <div class="riVal">range r=${String(p.rangeR)}, init range=${String(p.initR)}</div>

        <div class="riKey">Color map</div>
        <div class="riVal">${p.cmap || ""}<div class="riCmapBar" style="background:${p.cmapCSS || ""}"></div></div>

        <div class="riKey">Randomize</div>
        <div class="riVal">auto=${p.autoRandomizeRaw ? 'ON' : 'OFF'}, mode=${(p.randModeRaw==='ab') ? 'α/β only' : 'All params'}</div>

        <div class="riKey"></div>
        <div class="riVal" style="opacity:.75">Tap this entry to load + render again.</div>
      </div>
    `;

    const loadThis = (ev) => {
      if (ev) { ev.preventDefault(); ev.stopPropagation(); }
      lastRender = p;
      applyParamsToUI(p);
      // close menu if open, then draw using these exact settings
      showMenu(false);
      requestDraw();
      renderHistoryUI(p._id);
    };
    e.addEventListener('click', loadThis, { passive: false });
    e.addEventListener('pointerup', loadThis, { passive: false });
    e.addEventListener('touchend', loadThis, { passive: false });

    renderInfo.appendChild(e);
  }
}

function addRenderEntry(p){
  renderCount++;
  p._id = renderCount;

  lastRender = p;
  renderHistory.unshift(p);
  if (renderHistory.length > MAX_HISTORY) renderHistory.length = MAX_HISTORY;

  saveHistory();
  renderHistoryUI(p._id);
}

loadHistory();
renderHistoryUI(lastRender ? lastRender._id : null);


  function initColorMapSelect(){
    for (const n of Object.keys(ColorMaps)){
      const opt = document.createElement('option');
      opt.value = n;
      opt.textContent = n;
      elCmap.appendChild(opt);
    }
    elCmap.value = "Turbo";
  }

  function updateCmapPreview(){
    const name = elCmap.value;
    outCmap.textContent = name;
    const stops = [];
    for (let i=0;i<=10;i++){
      const t = i/10;
      const [r,g,b] = ColorMaps[name](t);
      stops.push(`rgb(${r|0},${g|0},${b|0}) ${Math.round(t*100)}%`);
    }
    cmPreview.style.background = `linear-gradient(90deg, ${stops.join(',')})`;
  }

  initColorMapSelect();
  updateCmapPreview();

  // ---------- Variants ----------
  const Variants = [
    { id:"classic_sqrt", name:"Classic (sqrt)", desc:"Wolfram/Martin: x' = y − sgn(x)·sqrt(|βx − δ|), y' = α − x",
      step:(x,y,a,b,g,d)=>{ const s=x>0?1:(x<0?-1:0); return [ y - s*Math.sqrt(Math.abs(b*x-d)), a - x ]; } },

    { id:"sqrt_plus_gamma_y", name:"Classic + γy", desc:"x' = y − sgn(x)·sqrt(|βx − δ|) + γy, y' = α − x",
      step:(x,y,a,b,g,d)=>{ const s=x>0?1:(x<0?-1:0); return [ y - s*Math.sqrt(Math.abs(b*x-d)) + g*y, a - x ]; } },

    { id:"sqrt_plus_gamma_x", name:"Classic + γx", desc:"x' = y − sgn(x)·sqrt(|βx − δ|) + γx, y' = α − x",
      step:(x,y,a,b,g,d)=>{ const s=x>0?1:(x<0?-1:0); return [ y - s*Math.sqrt(Math.abs(b*x-d)) + g*x, a - x ]; } },

    { id:"mix_inside", name:"sqrt(|β(x+γy)−δ|)", desc:"Mix x,y inside sqrt: x' = y − sgn(x)·sqrt(|β(x+γy) − δ|), y' = α − x",
      step:(x,y,a,b,g,d)=>{ const s=x>0?1:(x<0?-1:0); return [ y - s*Math.sqrt(Math.abs(b*(x+g*y)-d)), a - x ]; } },

    { id:"trig_kick_x", name:"Trig kick (sin x)", desc:"x' = y − sgn(x)·sqrt(|βx − δ|) + γ·sin(x), y' = α − x",
      step:(x,y,a,b,g,d)=>{ const s=x>0?1:(x<0?-1:0); return [ y - s*Math.sqrt(Math.abs(b*x-d)) + g*Math.sin(x), a - x ]; } },

    { id:"damped", name:"Damped (|γ|)", desc:"x' = (y − sgn(x)·sqrt(|βx − δ|))·(1−|γ|), y' = α − x",
      step:(x,y,a,b,g,d)=>{ const s=x>0?1:(x<0?-1:0); const base=y - s*Math.sqrt(Math.abs(b*x-d)); const damp=1-Math.min(0.95,Math.abs(g)); return [ base*damp, a - x ]; } },

    // -------- added formulas (10) --------
    { id:"y_feedback", name:"Y feedback (α−x+γy)", desc:"Keep classic x', add feedback on y: y' = α − x + γy",
      step:(x,y,a,b,g,d)=>{ const s=x>0?1:(x<0?-1:0); const xn=y - s*Math.sqrt(Math.abs(b*x-d)); const yn=a - x + g*y; return [xn, yn]; } },

    { id:"trig_kick_y", name:"Trig kick (sin y)", desc:"x' = y − sgn(x)·sqrt(|βx − δ|) + γ·sin(y), y' = α − x",
      step:(x,y,a,b,g,d)=>{ const s=x>0?1:(x<0?-1:0); return [ y - s*Math.sqrt(Math.abs(b*x-d)) + g*Math.sin(y), a - x ]; } },

    { id:"cos_xy_kick", name:"Trig kick (cos(x+y))", desc:"x' = y − sgn(x)·sqrt(|βx − δ|) + γ·cos(x+y), y' = α − x",
      step:(x,y,a,b,g,d)=>{ const s=x>0?1:(x<0?-1:0); return [ y - s*Math.sqrt(Math.abs(b*x-d)) + g*Math.cos(x+y), a - x ]; } },

    { id:"inside_sin_y", name:"Inside sqrt: x+γ·sin(y)", desc:"x' = y − sgn(x)·sqrt(|β(x+γ·sin(y)) − δ|), y' = α − x",
      step:(x,y,a,b,g,d)=>{ const s=x>0?1:(x<0?-1:0); const t=x + g*Math.sin(y); return [ y - s*Math.sqrt(Math.abs(b*t-d)), a - x ]; } },

    { id:"inside_cos_x", name:"Inside sqrt: x+γ·cos(x)", desc:"x' = y − sgn(x)·sqrt(|β(x+γ·cos(x)) − δ|), y' = α − x",
      step:(x,y,a,b,g,d)=>{ const s=x>0?1:(x<0?-1:0); const t=x + g*Math.cos(x); return [ y - s*Math.sqrt(Math.abs(b*t-d)), a - x ]; } },

    { id:"softsign_kick", name:"Softsign kick", desc:"x' = y − sgn(x)·sqrt(|βx − δ|) + γ·(x/(1+|x|)), y' = α − x",
      step:(x,y,a,b,g,d)=>{ const s=x>0?1:(x<0?-1:0); const k = x/(1+Math.abs(x)); return [ y - s*Math.sqrt(Math.abs(b*x-d)) + g*k, a - x ]; } },

    { id:"tanh_kick", name:"Tanh kick", desc:"x' = y − sgn(x)·sqrt(|βx − δ|) + γ·tanh(x), y' = α − x",
      step:(x,y,a,b,g,d)=>{ const s=x>0?1:(x<0?-1:0); const k = Math.tanh(x); return [ y - s*Math.sqrt(Math.abs(b*x-d)) + g*k, a - x ]; } },

    { id:"sign_xy", name:"Sign of (x·y)", desc:"Use sign(x·y): x' = y − sgn(xy)·sqrt(|βx − δ|), y' = α − x",
      step:(x,y,a,b,g,d)=>{ const p=x*y; const s=p>0?1:(p<0?-1:0); return [ y - s*Math.sqrt(Math.abs(b*x-d)), a - x ]; } },

    { id:"double_root", name:"Double-root kick", desc:"x' = y − sgn(x)·(sqrt(|βx−δ|)+γ·sqrt(|βy−δ|)), y' = α − x",
      step:(x,y,a,b,g,d)=>{ const s=x>0?1:(x<0?-1:0); const r1=Math.sqrt(Math.abs(b*x-d)); const r2=Math.sqrt(Math.abs(b*y-d)); return [ y - s*(r1 + g*r2), a - x ]; } },

    { id:"xy_coupling", name:"XY coupling", desc:"x' = y − sgn(x)·sqrt(|βx − δ|) + γ·(x·y/50), y' = α − x",
      step:(x,y,a,b,g,d)=>{ const s=x>0?1:(x<0?-1:0); const k=(x*y)/50; return [ y - s*Math.sqrt(Math.abs(b*x-d)) + g*k, a - x ]; } }
  ];

  
  function initFormulaSelect(){
    for (const v of Variants){
      const opt = document.createElement('option');
      opt.value = v.id;
      opt.textContent = v.name;
      elFormula.appendChild(opt);
    }
    elFormula.value = "classic_sqrt";
  }

  function getVariant() {
    const id = elFormula.value;
    return Variants.find(v => v.id === id) || Variants[0];
  }

  function updateFormulaDesc(){
    const v = getVariant();
    outFormula.textContent = v.name;
    elFormulaDesc.textContent = v.desc;
  }

  initFormulaSelect();
  updateFormulaDesc();

  // ---------- sync UI ----------
  function syncUI() {
    outRandomize.textContent = elRandomize.checked ? "ON" : "OFF";
    outAlpha.textContent = (+elAlpha.value).toFixed(6);
    outBeta.textContent = (+elBeta.value).toFixed(6);
    outGamma.textContent = (+elGamma.value).toFixed(6);
    outDelta.textContent = String(getDelta());
    outOrbits.textContent = String(parseInt(elOrbits.value, 10));
    outIters.textContent = String(parseInt(elIters.value, 10));
    outBurn.textContent = String(parseInt(elBurn.value, 10));
    outRangeR.textContent = String(parseInt(elRangeR.value, 10));
    outInitR.textContent = String(parseInt(elInitR.value, 10));
    elRandModeOut.textContent = (getRandMode() === "ab") ? "α/β only" : "All params";
    updateCmapPreview();
    updateFormulaDesc();
  }

  [
    elFormula, ...randModeRadios, elRandomize, elAlpha, elBeta, elGamma,
    elOrbits, elIters, elBurn, elRangeR, elInitR, elCmap, ...deltaRadios
  ].forEach(el => el.addEventListener('input', syncUI));

  elCmap.addEventListener('change', syncUI);
  elFormula.addEventListener('change', syncUI);

  syncUI();

  // ---------- controls show/hide (clean screen) ----------
  const viewControlsEl = document.getElementById('viewControls');
  let controlsVisible = false;
  function showControls(show){
    controlsVisible = !!show;
    if (viewControlsEl) viewControlsEl.style.display = controlsVisible ? 'grid' : 'none';
  }
  // start clean
  showControls(false);

  // ---------- menu show/hide ----------
  function showMenu(show) {
    menu.style.display = show ? 'block' : 'none';
    backdrop.style.display = show ? 'block' : 'none';
    inMenu = show;
    if (show && lastRender) {
      // When opening the menu, present the parameters used for the last render.
      applyParamsToUI(lastRender);
    }
  }

  backdrop.addEventListener('pointerdown', (e) => {
    e.preventDefault();
    abortDraw = true;
    showMenu(false);
    showControls(false);
    requestDraw();
  }, { passive: false });

  // ---------- gesture handling ----------
  let inMenu = false;
  let drawing = false;
  let abortDraw = false;

  const LONG_PRESS_MS = 520;
  let pressTimer = null;
  let moved = false;

  // ---------- pointer gesture state (pan/zoom) ----------
  const TAP_MOVE_PX = 8 * (window.devicePixelRatio || 1); // movement beyond this is a drag, not a tap
  const MIN_ZOOM = 0.15;
  const MAX_ZOOM = 20.0;

  const activePtrs = new Map(); // pointerId -> {x,y}
  let gestureMode = 'none';     // 'none' | 'drag' | 'pinch'
  let dragLastX = 0, dragLastY = 0;

  // helpers: current screen->world mapping (uses lastBaseR + viewPan + viewZoom)
  function _evtToCanvasPx(ev){
    const rect = canvas.getBoundingClientRect();
    const sx = canvas.width / rect.width;
    const sy = canvas.height / rect.height;
    return { x: (ev.clientX - rect.left) * sx, y: (ev.clientY - rect.top) * sy };
  }
  function _screenToWorld(px, py) {
    const w = canvas.width, h = canvas.height;
    const r = lastBaseR || 1;
    const sx = ((w - 1) / (2 * r)) * viewZoom;
    const sy = ((h - 1) / (2 * r)) * viewZoom;
    return {
      x: (px / sx) - r + viewPanX,
      y: r - (py / sy) + viewPanY
    };
  }
  function _applyZoomAroundScreenPoint(newZoom, px, py) {
    newZoom = Math.min(MAX_ZOOM, Math.max(MIN_ZOOM, newZoom));
    if (!lastBaseR) { viewZoom = newZoom; return; }

    const before = _screenToWorld(px, py);

    const w = canvas.width, h = canvas.height;
    const r = lastBaseR;
    const sx2 = ((w - 1) / (2 * r)) * newZoom;
    const sy2 = ((h - 1) / (2 * r)) * newZoom;

    // solve for pan that keeps 'before' under the same screen point
    viewPanX = before.x - (px / sx2) + r;
    viewPanY = before.y - r + (py / sy2);
    viewZoom = newZoom;
  }

  function onPressStart(e) {
    moved = false;

    // track pointers (for touch + mouse)
    const pt = _evtToCanvasPx(e);
    activePtrs.set(e.pointerId, { x: pt.x, y: pt.y });

    // long-press toggles control panel (only when starting a fresh gesture)
    if (activePtrs.size === 1) {
      dragLastX = pt.x; dragLastY = pt.y;
      gestureMode = 'drag';

      if (pressTimer) clearTimeout(pressTimer);
      pressTimer = setTimeout(() => {
        pressTimer = null;
        showMenu(true);
      }, LONG_PRESS_MS);
    } else if (activePtrs.size === 2) {
      // begin pinch
      gestureMode = 'pinch';
      moved = true;
      if (pressTimer) { clearTimeout(pressTimer); pressTimer = null; }

      // stash pinch baseline
      const pts = Array.from(activePtrs.values());
      pinchStart = {
        d: Math.hypot(pts[0].x - pts[1].x, pts[0].y - pts[1].y),
        zoom: viewZoom,
        mx: (pts[0].x + pts[1].x) * 0.5,
        my: (pts[0].y + pts[1].y) * 0.5
      };
    } else {
      // 3+ fingers: ignore for now
      moved = true;
      if (pressTimer) { clearTimeout(pressTimer); pressTimer = null; }
    }
  }

  let pinchStart = null;

  function onPressMove(e) {
    if (!activePtrs.has(e.pointerId)) return;
    const pt = _evtToCanvasPx(e);
    activePtrs.set(e.pointerId, { x: pt.x, y: pt.y });

    // cancel long-press once movement is meaningful
    const dx0 = pt.x - dragLastX;
    const dy0 = pt.y - dragLastY;
    const dist0 = Math.hypot(dx0, dy0);

    if (gestureMode === 'drag' && activePtrs.size === 1) {
      if (dist0 > TAP_MOVE_PX) {
        moved = true;
        if (pressTimer) { clearTimeout(pressTimer); pressTimer = null; }
      }
      if (!moved) return; // still a tap candidate

      if (!lastBaseR) return;

      const w = canvas.width, h = canvas.height;
      const r = lastBaseR;
      const sx = ((w - 1) / (2 * r)) * viewZoom;
      const sy = ((h - 1) / (2 * r)) * viewZoom;

      // drag in screen px -> pan in world units
      viewPanX -= dx0 / sx;
      viewPanY += dy0 / sy;

      dragLastX = pt.x; dragLastY = pt.y;
      redrawLastRender();
      return;
    }

    if (gestureMode === 'pinch' && activePtrs.size >= 2 && pinchStart) {
      moved = true;
      if (pressTimer) { clearTimeout(pressTimer); pressTimer = null; }

      const pts = Array.from(activePtrs.values()).slice(0,2);
      const d = Math.hypot(pts[0].x - pts[1].x, pts[0].y - pts[1].y);
      if (pinchStart.d <= 0) return;

      const ratio = d / pinchStart.d;
      const newZoom = pinchStart.zoom * ratio;
      _applyZoomAroundScreenPoint(newZoom, pinchStart.mx, pinchStart.my);
      redrawLastRender();
      return;
    }
  }

  function onPressEnd(e) {
    activePtrs.delete(e.pointerId);

    // transition pinch->drag if one finger remains
    if (gestureMode === 'pinch' && activePtrs.size === 1) {
      const pt = Array.from(activePtrs.values())[0];
      gestureMode = 'drag';
      dragLastX = pt.x; dragLastY = pt.y;
      pinchStart = null;
      return;
    }

    if (activePtrs.size === 0) {
      gestureMode = 'none';
      pinchStart = null;

      // tap-to-render behaviour (unchanged): only when no gesture movement and UI hidden
      if (!pressTimer) return;
      clearTimeout(pressTimer);
      pressTimer = null;
      if (!moved && !inMenu && !controlsVisible) requestDraw();
    }
  }

  canvas.addEventListener('pointerdown', onPressStart, { passive: true });
  canvas.addEventListener('pointermove', onPressMove, { passive: true });
  canvas.addEventListener('pointerup', onPressEnd, { passive: true });
  canvas.addEventListener('pointercancel', onPressEnd, { passive: true });

  // mouse wheel / trackpad zoom (desktop)
  canvas.addEventListener('wheel', (e) => {
    if (!lastBaseR) return;
    e.preventDefault();
    const factor = (e.deltaY < 0) ? 1.12 : (1/1.12);
    const pt = _evtToCanvasPx(e);
    _applyZoomAroundScreenPoint(viewZoom * factor, pt.x, pt.y);
    redrawLastRender();
  }, { passive: false });
  window.addEventListener('contextmenu', (e) => e.preventDefault());

  // Also suppress context menus on key overlays (iPad long-press)
  ;[canvas, viewControlsEl, renderInfo, document.getElementById('installHint')].forEach(el => {
    if (!el) return;
    el.addEventListener('contextmenu', (e)=>{ e.preventDefault(); }, { passive: false });
  });

  // ---------- helpers ----------
  function randUniform(lo, hi) { return lo + Math.random() * (hi - lo); }
  function randInt(lo, hi) { return Math.floor(lo + Math.random() * (hi - lo + 1)); }
  function pick(arr) { return arr[Math.floor(Math.random() * arr.length)]; }

  function setDelta(v) {
    deltaRadios.forEach(r => r.checked = (parseInt(r.value, 10) === v));
  }

  function setRandMode(v) {
    randModeRadios.forEach(r => r.checked = (r.value === v));
  }

  // ---------- dual randomize ----------
  function randomizeAlphaBeta() {
    elAlpha.value = randUniform(-100, 100).toFixed(6);
    elBeta.value = randUniform(-100, 100).toFixed(6);
  }

  function randomizeAllParams() {
    // formula
    elFormula.value = pick(Variants).id;

    // alpha/beta
    randomizeAlphaBeta();

    // gamma (keep moderate most of the time for stability)
    elGamma.value = randUniform(-1.5, 1.5).toFixed(6);

    // delta
    setDelta(Math.random() < 0.5 ? 0 : 1);

    // orbits / iters / burn
    elOrbits.value = String(pick([10, 25, 50, 60]));
    elIters.value  = String(pick([2000, 4000, 8000, 12000, 16000]));
    elBurn.value   = String(pick([0, 20, 50, 100, 200]));

    // range / init range
    elRangeR.value = String(pick([150, 200, 250, 300, 400, 600]));
    elInitR.value  = String(pick([30, 50, 80, 100, 150]));

    // colormap
    elCmap.value = pick(Object.keys(ColorMaps));
  }

  function applyRandomizeModeIfEnabled() {
    // Randomize ONLY the parameters whose per-parameter flags are checked.
    // (Legacy global controls are hidden; we keep this entry point for compatibility.)
    if (!rand) return;

    // formula
    if (rand.formula && rand.formula.checked) elFormula.value = pick(Variants).id;

    // alpha / beta
    if ((rand.alpha && rand.alpha.checked) || (rand.beta && rand.beta.checked)) {
      if (rand.alpha && rand.alpha.checked) elAlpha.value = randUniform(-100, 100).toFixed(6);
      if (rand.beta  && rand.beta.checked)  elBeta.value  = randUniform(-100, 100).toFixed(6);
    }

    // gamma
    if (rand.gamma && rand.gamma.checked) elGamma.value = randUniform(-1.5, 1.5).toFixed(6);

    // delta
    if (rand.delta && rand.delta.checked) setDelta(Math.random() < 0.5 ? 0 : 1);

    // orbits / iters / burn
    if (rand.orbits && rand.orbits.checked) elOrbits.value = String(pick([10, 25, 50, 60]));
    if (rand.iters  && rand.iters.checked)  elIters.value  = String(pick([2000, 4000, 8000, 12000, 16000]));
    if (rand.burn   && rand.burn.checked)   elBurn.value   = String(pick([0, 20, 50, 100, 200]));

    // range / init range
    if (rand.rangeR && rand.rangeR.checked) elRangeR.value = String(pick([150, 200, 250, 300, 400, 600]));
    if (rand.initR  && rand.initR.checked)  elInitR.value  = String(pick([30, 50, 80, 100, 150]));

    // colormap
    if (rand.cmap && rand.cmap.checked) elCmap.value = pick(Object.keys(ColorMaps));

    syncUI();
  }

  // ---------- colormap to orbit colors ----------
  function makeOrbitColors(N, cmapName) {
    const cmap = ColorMaps[cmapName] || ColorMaps["Turbo"];
    const cols = new Array(N);
    if (N <= 1) {
      cols[0] = cmap(0.5).map(x => x|0);
      return cols;
    }
    for (let i=0;i<N;i++){
      const t = i / (N - 1);
      const c = cmap(t);
      cols[i] = [c[0]|0, c[1]|0, c[2]|0];
    }
    return cols;
  }

  // ---------- draw ----------
  function requestDraw() {
    if (drawing || inMenu) return;
    abortDraw = false;
    drawHopalong();
  }

  function drawHopalong() {
    drawing = true;

    // auto randomize (based on mode)
    applyRandomizeModeIfEnabled();

    const a = +elAlpha.value;
    const b = +elBeta.value;
    const g = +elGamma.value;
    const d = getDelta();

    const variant = getVariant();
    const N = parseInt(elOrbits.value, 10);
    const iters = parseInt(elIters.value, 10);
    const burn = parseInt(elBurn.value, 10);
    const r = parseFloat(elRangeR.value);
    const initR = parseFloat(elInitR.value);

    const w = canvas.width, h = canvas.height;
    const sx = (w - 1) / (2 * r);
    const sy = (h - 1) / (2 * r);
    const xoff = r, yoff = r;

    const orbitColors = makeOrbitColors(N, elCmap.value);

    // allocate storage for this render so we can re-draw with pan/zoom without recomputing
    const maxPts = Math.max(0, N * Math.max(0, iters - burn));
    const ptsXY = new Float32Array(maxPts * 2);
    const ptOrbit = new Uint16Array(maxPts);
    let ptCount = 0;

    // reset view for a fresh render
    resetView();


    // clear buffer
    for (let i = 0; i < buf.length; i += 4) {
      buf[i] = 0; buf[i+1] = 0; buf[i+2] = 0; buf[i+3] = 255;
    }

    let orbitIdx = 0;

    function stepFrame() {
      if (abortDraw || inMenu) {
        drawing = false;
        ctx.putImageData(img, 0, 0);
        return;
      }

      const orbitsPerFrame = 3;
      let done = 0;

      while (orbitIdx < N && done < orbitsPerFrame) {
        let x = randUniform(-initR, initR);
        let y = randUniform(-initR, initR);

        const col = orbitColors[orbitIdx];
        const rr = col[0], gg = col[1], bb = col[2];

        // burn-in
        for (let k = 0; k < burn; k++) {
          const res = variant.step(x, y, a, b, g, d);
          x = res[0]; y = res[1];
          if (!Number.isFinite(x) || !Number.isFinite(y)) { x = 0; y = 0; break; }
        }

        // plot
        for (let k = burn; k < iters; k++) {
          const res = variant.step(x, y, a, b, g, d);
          x = res[0]; y = res[1];
          if (!Number.isFinite(x) || !Number.isFinite(y)) break;

          // store world point for later pan/zoom redraw
          if (ptCount < maxPts) { ptsXY[ptCount*2] = x; ptsXY[ptCount*2+1] = y; ptOrbit[ptCount] = orbitIdx; ptCount++; }

          const px = (((x - viewPanX) + xoff) * (sx * viewZoom)) | 0;
          const py = ((yoff - (y - viewPanY)) * (sy * viewZoom)) | 0;

          if ((px >>> 0) < w && (py >>> 0) < h) {
            setPixel(px, py, rr, gg, bb);
          }

          if ((k & 1023) === 0 && (abortDraw || inMenu)) break;
        }

        orbitIdx++;
        done++;
      }

      ctx.putImageData(img, 0, 0);

      if (orbitIdx < N) requestAnimationFrame(stepFrame);
      else {
        drawing = false;
        ctx.putImageData(img, 0, 0);

        // store last render data for view-only pan/zoom
        lastPtsXY = ptsXY;
        lastPtOrbit = ptOrbit;
        lastPtCount = ptCount;
        lastOrbitColors = orbitColors;
        lastBaseR = r;

        // log parameters for this render
        addRenderEntry({
          completed: true,
          when: nowStamp(),
          formulaId: variant.id,
          formulaName: variant.name,
          formulaDesc: variant.desc,
          alpha: a,
          beta: b,
          gamma: g,
          delta: d,
          N: N,
          iters: iters,
          burn: burn,
          rangeR: r,
          initR: initR,
          cmap: elCmap.value,
          cmapCSS: cmapGradientCSS(elCmap.value),
          autoRandomizeRaw: !!elRandomize.checked,
          randModeRaw: getRandMode()
        });
      }
    }

    requestAnimationFrame(stepFrame);
  }

  // buttons
  btnApply.addEventListener('click', () => {
    syncUI();
    showMenu(false);
    showControls(false);
    requestDraw();
  });
  btnClose.addEventListener('click', () => { showMenu(false); showControls(false); });

  // Start with immediate draw
  setTimeout(() => requestDraw(), 50);

})();

  // --- suppress Safari selection/callout in overlays ---
  document.addEventListener('contextmenu', (e) => {
    if (e.target === canvas || menu.contains(e.target) || renderInfo.contains(e.target)) e.preventDefault();
  }, { passive: false });

  document.addEventListener('selectstart', (e) => {
    if (e.target === canvas || menu.contains(e.target) || renderInfo.contains(e.target)) e.preventDefault();
  });

  // --- iOS: prevent text selection/callout in menu and improve slider dragging ---
  (function(){
    const menu = document.getElementById('menu');
    if (!menu) return;

    const kill = (ev)=>{ ev.preventDefault(); };
    menu.addEventListener('contextmenu', kill);
    menu.addEventListener('selectstart', kill);

    // If user is interacting with a range slider, temporarily disable menu scroll
    const armNoScroll = ()=>menu.classList.add('noScroll');
    const disarmNoScroll = ()=>menu.classList.remove('noScroll');

    const ranges = menu.querySelectorAll('input[type="range"]');
    ranges.forEach(r=>{
      r.addEventListener('pointerdown', (ev)=>{ ev.stopPropagation(); armNoScroll(); }, {passive:true});
      r.addEventListener('pointerup',   (ev)=>{ ev.stopPropagation(); disarmNoScroll(); }, {passive:true});
      r.addEventListener('pointercancel',(ev)=>{ ev.stopPropagation(); disarmNoScroll(); }, {passive:true});

      r.addEventListener('touchstart', (ev)=>{ ev.stopPropagation(); armNoScroll(); }, {passive:true});
      r.addEventListener('touchend',   (ev)=>{ ev.stopPropagation(); disarmNoScroll(); }, {passive:true});
      r.addEventListener('touchcancel',(ev)=>{ ev.stopPropagation(); disarmNoScroll(); }, {passive:true});
    });
  })();

</script>
</body>
</html>
