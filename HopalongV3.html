<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Hopalong Variations — Dual Randomize</title>
  <style>
    :root { color-scheme: dark; }
    html, body { height: 100%; margin: 0; background: #000; }
    canvas { width: 100%; height: 100%; display: block; touch-action: none; }

    #backdrop {
      position: fixed; inset: 0;
      background: rgba(0,0,0,0.0);
      display: none;
      z-index: 9;
      touch-action: none;
    }

    #menu {
      position: fixed;
      inset: 12px;
      max-width: 860px;
      border: 1px solid rgba(255,255,255,.18);
      border-radius: 16px;
      background: rgba(16,16,16,.92);
      color: #fff;
      padding: 14px 14px 10px 14px;
      display: none;
      overflow: auto;
      -webkit-backdrop-filter: blur(10px);
      backdrop-filter: blur(10px);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      z-index: 10;
    }

    #menuTop {
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
      position: sticky;
      top: 0;
      padding: 4px 0 10px 0;
      background: rgba(16,16,16,.92);
      z-index: 11;
    }
    #menuTop h2 { margin: 0; font-size: 16px; font-weight: 800; }
    #menuBtns { display: flex; gap: 10px; align-items: center; }
    button {
      border: 1px solid rgba(255,255,255,.25);
      background: rgba(255,255,255,.08);
      color: #fff;
      padding: 10px 12px;
      border-radius: 12px;
      font-weight: 700;
    }

    .row {
      display: grid;
      grid-template-columns: 190px 1fr 170px;
      gap: 10px;
      align-items: center;
      padding: 8px 0;
      border-bottom: 1px solid rgba(255,255,255,.08);
    }
    .row:last-child { border-bottom: none; }
    .row label { opacity: .9; }
    .row output { text-align: right; font-variant-numeric: tabular-nums; opacity: .95; }
    input[type="range"], select { width: 100%; }

    .cmPreview {
      height: 12px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.18);
      background: linear-gradient(90deg, #000, #fff);
    }
    .subnote { font-size: 12px; opacity: .75; margin-top: 10px; line-height: 1.35; }
    code { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
  </style>
</head>
<body>
<canvas id="c"></canvas>
<div id="backdrop"></div>

<div id="menu">
  <div id="menuTop">
    <h2>Hopalong (dual randomize)</h2>
    <div id="menuBtns">
      <button id="btnApply">Apply + Draw</button>
      <button id="btnClose">Close</button>
    </div>
  </div>

  <div class="row">
    <label>Formula</label>
    <div style="display:flex; flex-direction:column; gap:8px;">
      <select id="formula"></select>
      <div style="font-size:12px; opacity:.8" id="formulaDesc"></div>
    </div>
    <output id="formulaOut">Classic (sqrt)</output>
  </div>

  <div class="row">
    <label>Randomize mode</label>
    <div style="display:flex; gap:12px; flex-wrap:wrap; align-items:center;">
      <label style="display:flex; gap:6px; align-items:center;">
        <input type="radio" name="randMode" value="ab" checked />
        α/β only
      </label>
      <label style="display:flex; gap:6px; align-items:center;">
        <input type="radio" name="randMode" value="all" />
        All params
      </label>
    </div>
    <output id="randModeOut">α/β only</output>
  </div>

  <div class="row">
    <label>Auto-randomize</label>
    <input id="randomize" type="checkbox" />
    <output id="randomizeOut">ON</output>
  </div>

  <div class="row">
    <label>α (alpha)</label>
    <input id="alpha" type="range" min="-100" max="100" step="0.001" value="1.0" />
    <output id="alphaOut">1.000000</output>
  </div>

  <div class="row">
    <label>β (beta)</label>
    <input id="beta" type="range" min="-100" max="100" step="0.001" value="19.0" />
    <output id="betaOut">19.000000</output>
  </div>

  <div class="row">
    <label>γ (gamma)</label>
    <input id="gamma" type="range" min="-5" max="5" step="0.001" value="0.0" />
    <output id="gammaOut">0.000000</output>
  </div>

  <div class="row">
    <label>δ (delta)</label>
    <div style="display:flex; gap:10px; align-items:center;">
      <label style="display:flex; gap:6px; align-items:center;"><input type="radio" name="delta" value="0" checked />0</label>
      <label style="display:flex; gap:6px; align-items:center;"><input type="radio" name="delta" value="1" />1</label>
    </div>
    <output id="deltaOut">0</output>
  </div>

  <div class="row">
    <label>Orbits (N)</label>
    <input id="orbits" type="range" min="1" max="80" step="1" value="25" />
    <output id="orbitsOut">25</output>
  </div>

  <div class="row">
    <label>Iters</label>
    <input id="iters" type="range" min="500" max="50000" step="100" value="8000" />
    <output id="itersOut">8000</output>
  </div>

  <div class="row">
    <label>Burn-in</label>
    <input id="burn" type="range" min="0" max="5000" step="5" value="50" />
    <output id="burnOut">50</output>
  </div>

  <div class="row">
    <label>Range r</label>
    <input id="rangeR" type="range" min="20" max="2000" step="1" value="300" />
    <output id="rangeROut">300</output>
  </div>

  <div class="row">
    <label>Init range</label>
    <input id="initR" type="range" min="10" max="300" step="1" value="100" />
    <output id="initROut">100</output>
  </div>

  <div class="row">
    <label>Color map</label>
    <div style="display:flex; flex-direction:column; gap:8px;">
      <select id="cmap"></select>
      <div class="cmPreview" id="cmPreview"></div>
    </div>
    <output id="cmapOut">Turbo</output>
  </div>

  <div class="subnote">
    Gestures:
    <br>• Short tap (menu hidden): <b>redraw</b>
    <br>• Long press (~0.5s): <b>toggle menu</b>
    <br>• Menu open: <b>tap outside</b> closes + draws
    <br><br>
    Randomize:
    <br>• If Auto-randomize ON, each redraw randomizes using the selected mode.
    <br>• α/β only mode keeps formula, γ, δ, N, iters, burn, range, init, colormap unchanged.
    <br>• All params mode randomizes <i>everything in the menu</i> (formula, γ, δ, N, iters, burn, range, init, colormap) as well as α/β.
  </div>
</div>

<script>
(() => {
  // ---------- canvas / pixel buffer ----------
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: false });
  let img, buf;

  function resize() {
    const dpr = window.devicePixelRatio || 1;
    canvas.width  = Math.floor(window.innerWidth  * dpr);
    canvas.height = Math.floor(window.innerHeight * dpr);
    ctx.imageSmoothingEnabled = false;
    img = ctx.createImageData(canvas.width, canvas.height);
    buf = img.data;
    clearScreen();
  }
  window.addEventListener('resize', resize, { passive: true });

  function clearScreen() {
    for (let i = 0; i < buf.length; i += 4) {
      buf[i] = 0; buf[i+1] = 0; buf[i+2] = 0; buf[i+3] = 255;
    }
    ctx.putImageData(img, 0, 0);
  }
  resize();

  function setPixel(x, y, r, g, b) {
    const idx = (y * canvas.width + x) * 4;
    buf[idx] = r; buf[idx+1] = g; buf[idx+2] = b; buf[idx+3] = 255;
  }

  // ---------- UI / menu ----------
  const menu = document.getElementById('menu');
  const backdrop = document.getElementById('backdrop');
  const btnApply = document.getElementById('btnApply');
  const btnClose = document.getElementById('btnClose');

  const elFormula = document.getElementById('formula');
  const elFormulaDesc = document.getElementById('formulaDesc');
  const outFormula = document.getElementById('formulaOut');

  const elRandModeOut = document.getElementById('randModeOut');
  const randModeRadios = Array.from(document.querySelectorAll('input[name="randMode"]'));

  const elRandomize = document.getElementById('randomize');
  const elAlpha = document.getElementById('alpha');
  const elBeta = document.getElementById('beta');
  const elGamma = document.getElementById('gamma');
  const elOrbits = document.getElementById('orbits');
  const elIters = document.getElementById('iters');
  const elBurn = document.getElementById('burn');
  const elRangeR = document.getElementById('rangeR');
  const elInitR = document.getElementById('initR');
  const elCmap = document.getElementById('cmap');
  const cmPreview = document.getElementById('cmPreview');

  const outRandomize = document.getElementById('randomizeOut');
  const outAlpha = document.getElementById('alphaOut');
  const outBeta = document.getElementById('betaOut');
  const outGamma = document.getElementById('gammaOut');
  const outDelta = document.getElementById('deltaOut');
  const outOrbits = document.getElementById('orbitsOut');
  const outIters = document.getElementById('itersOut');
  const outBurn = document.getElementById('burnOut');
  const outRangeR = document.getElementById('rangeROut');
  const outInitR = document.getElementById('initROut');
  const outCmap = document.getElementById('cmapOut');

  const deltaRadios = Array.from(document.querySelectorAll('input[name="delta"]'));
  function getDelta() {
    const r = deltaRadios.find(x => x.checked);
    return r ? parseInt(r.value, 10) : 0;
  }

  function getRandMode() {
    const r = randModeRadios.find(x => x.checked);
    return r ? r.value : "ab";
  }

  // ---------- colormaps ----------
  function clamp01(x){ return x < 0 ? 0 : (x > 1 ? 1 : x); }
  function lerp(a,b,t){ return a + (b-a)*t; }
  function lerp3(c1,c2,t){ return [lerp(c1[0],c2[0],t), lerp(c1[1],c2[1],t), lerp(c1[2],c2[2],t)]; }
  function fromStops(stops, t){
    t = clamp01(t);
    for (let i=0; i<stops.length-1; i++){
      const a = stops[i], b = stops[i+1];
      if (t >= a[0] && t <= b[0]){
        const u = (t - a[0]) / (b[0] - a[0] || 1);
        return lerp3(a[1], b[1], u);
      }
    }
    return stops[stops.length-1][1];
  }

  const ColorMaps = {
    "Turbo": (t) => fromStops([
      [0.00,[48,18,59]],[0.10,[50,44,125]],[0.20,[32,96,189]],[0.30,[41,158,179]],
      [0.40,[93,201,99]],[0.50,[177,222,44]],[0.60,[236,199,24]],[0.70,[250,144,25]],
      [0.80,[243,85,38]],[0.90,[206,41,57]],[1.00,[122,4,3]]
    ], t),
    "Viridis": (t) => fromStops([[0,[68,1,84]],[.25,[59,82,139]],[.5,[33,145,140]],[.75,[94,201,98]],[1,[253,231,37]]], t),
    "Plasma": (t) => fromStops([[0,[13,8,135]],[.25,[126,3,167]],[.5,[203,71,119]],[.75,[248,149,64]],[1,[240,249,33]]], t),
    "Inferno": (t) => fromStops([[0,[0,0,4]],[.25,[87,15,109]],[.5,[187,55,84]],[.75,[249,142,8]],[1,[252,255,164]]], t),
    "Magma": (t) => fromStops([[0,[0,0,4]],[.25,[78,18,123]],[.5,[182,54,121]],[.75,[251,136,97]],[1,[252,253,191]]], t),
    "Gray": (t) => { const v = Math.round(255*clamp01(t)); return [v,v,v]; },
    "Rainbow": (t) => {
      t = clamp01(t);
      const h = (1 - t) * 240;
      const c = 1, hp = h/60, x = c*(1-Math.abs((hp%2)-1));
      let r=0,g=0,b=0;
      if (hp<1){ r=c; g=x; } else if (hp<2){ r=x; g=c; }
      else if (hp<3){ g=c; b=x; } else if (hp<4){ g=x; b=c; }
      else if (hp<5){ r=x; b=c; } else { r=c; b=x; }
      return [Math.round(r*255),Math.round(g*255),Math.round(b*255)];
    },
    "Heat": (t) => fromStops([[0,[0,0,0]],[.33,[180,0,0]],[.66,[255,160,0]],[1,[255,255,255]]], t),
    "Ocean": (t) => fromStops([[0,[0,0,0]],[.25,[0,20,70]],[.5,[0,90,160]],[.75,[40,180,220]],[1,[220,250,255]]], t)
  };

  function initColorMapSelect(){
    for (const n of Object.keys(ColorMaps)){
      const opt = document.createElement('option');
      opt.value = n;
      opt.textContent = n;
      elCmap.appendChild(opt);
    }
    elCmap.value = "Turbo";
  }

  function updateCmapPreview(){
    const name = elCmap.value;
    outCmap.textContent = name;
    const stops = [];
    for (let i=0;i<=10;i++){
      const t = i/10;
      const [r,g,b] = ColorMaps[name](t);
      stops.push(`rgb(${r|0},${g|0},${b|0}) ${Math.round(t*100)}%`);
    }
    cmPreview.style.background = `linear-gradient(90deg, ${stops.join(',')})`;
  }

  initColorMapSelect();
  updateCmapPreview();

  // ---------- Variants ----------
  const Variants = [
    { id:"classic_sqrt", name:"Classic (sqrt)", desc:"Wolfram/Martin: x' = y − sgn(x)·sqrt(|βx − δ|), y' = α − x",
      step:(x,y,a,b,g,d)=>{ const s=x>0?1:(x<0?-1:0); return [ y - s*Math.sqrt(Math.abs(b*x-d)), a - x ]; } },
    { id:"sqrt_plus_gamma_y", name:"Classic + γy", desc:"x' = y − sgn(x)·sqrt(|βx − δ|) + γy, y' = α − x",
      step:(x,y,a,b,g,d)=>{ const s=x>0?1:(x<0?-1:0); return [ y - s*Math.sqrt(Math.abs(b*x-d)) + g*y, a - x ]; } },
    { id:"sqrt_plus_gamma_x", name:"Classic + γx", desc:"x' = y − sgn(x)·sqrt(|βx − δ|) + γx, y' = α − x",
      step:(x,y,a,b,g,d)=>{ const s=x>0?1:(x<0?-1:0); return [ y - s*Math.sqrt(Math.abs(b*x-d)) + g*x, a - x ]; } },
    { id:"abs_no_sqrt", name:"No sqrt (|·|)", desc:"x' = y − sgn(x)·|βx − δ|, y' = α − x",
      step:(x,y,a,b,g,d)=>{ const s=x>0?1:(x<0?-1:0); return [ y - s*Math.abs(b*x-d), a - x ]; } },
    { id:"pow_p", name:"Power p (γ controls p)", desc:"Replace sqrt with |·|^p, p mapped from γ.",
      step:(x,y,a,b,g,d)=>{ const p=Math.max(0.15,Math.min(2.0, (g+5)/10*1.6+0.2)); const s=x>0?1:(x<0?-1:0); return [ y - s*Math.pow(Math.abs(b*x-d), p), a - x ]; } },
    { id:"swap_feedback", name:"Swap feedback", desc:"Kick uses y: x' = y − sgn(y)·sqrt(|βy − δ|), y' = α − x",
      step:(x,y,a,b,g,d)=>{ const s=y>0?1:(y<0?-1:0); return [ y - s*Math.sqrt(Math.abs(b*y-d)), a - x ]; } },
    { id:"mix_inside", name:"sqrt(|β(x+γy)−δ|)", desc:"Mix x,y inside sqrt: x' = y − sgn(x)·sqrt(|β(x+γy) − δ|), y' = α − x",
      step:(x,y,a,b,g,d)=>{ const s=x>0?1:(x<0?-1:0); return [ y - s*Math.sqrt(Math.abs(b*(x+g*y)-d)), a - x ]; } },
    { id:"trig_kick", name:"Trig kick", desc:"x' = y − sgn(x)·sqrt(|βx − δ|) + γ·sin(x), y' = α − x",
      step:(x,y,a,b,g,d)=>{ const s=x>0?1:(x<0?-1:0); return [ y - s*Math.sqrt(Math.abs(b*x-d)) + g*Math.sin(x), a - x ]; } },
    { id:"damped", name:"Damped (|γ|)", desc:"x' = (y − sgn(x)·sqrt(|βx − δ|))·(1−|γ|), y' = α − x",
      step:(x,y,a,b,g,d)=>{ const s=x>0?1:(x<0?-1:0); const base=y - s*Math.sqrt(Math.abs(b*x-d)); const damp=1-Math.min(0.95,Math.abs(g)); return [ base*damp, a - x ]; } },
    { id:"y_update_variant", name:"Alt y update", desc:"Keep classic x', change y' = α − y (different feedback)",
      step:(x,y,a,b,g,d)=>{ const s=x>0?1:(x<0?-1:0); const xn=y - s*Math.sqrt(Math.abs(b*x-d)); const yn=a - y; return [xn, yn]; } }
  ];

  function initFormulaSelect(){
    for (const v of Variants){
      const opt = document.createElement('option');
      opt.value = v.id;
      opt.textContent = v.name;
      elFormula.appendChild(opt);
    }
    elFormula.value = "classic_sqrt";
  }

  function getVariant() {
    const id = elFormula.value;
    return Variants.find(v => v.id === id) || Variants[0];
  }

  function updateFormulaDesc(){
    const v = getVariant();
    outFormula.textContent = v.name;
    elFormulaDesc.textContent = v.desc;
  }

  initFormulaSelect();
  updateFormulaDesc();

  // ---------- sync UI ----------
  function syncUI() {
    outRandomize.textContent = elRandomize.checked ? "ON" : "OFF";
    outAlpha.textContent = (+elAlpha.value).toFixed(6);
    outBeta.textContent = (+elBeta.value).toFixed(6);
    outGamma.textContent = (+elGamma.value).toFixed(6);
    outDelta.textContent = String(getDelta());
    outOrbits.textContent = String(parseInt(elOrbits.value, 10));
    outIters.textContent = String(parseInt(elIters.value, 10));
    outBurn.textContent = String(parseInt(elBurn.value, 10));
    outRangeR.textContent = String(parseInt(elRangeR.value, 10));
    outInitR.textContent = String(parseInt(elInitR.value, 10));
    elRandModeOut.textContent = (getRandMode() === "ab") ? "α/β only" : "All params";
    updateCmapPreview();
    updateFormulaDesc();
  }

  [
    elFormula, ...randModeRadios, elRandomize, elAlpha, elBeta, elGamma,
    elOrbits, elIters, elBurn, elRangeR, elInitR, elCmap, ...deltaRadios
  ].forEach(el => el.addEventListener('input', syncUI));

  elCmap.addEventListener('change', syncUI);
  elFormula.addEventListener('change', syncUI);

  syncUI();

  // ---------- menu show/hide ----------
  function showMenu(show) {
    menu.style.display = show ? 'block' : 'none';
    backdrop.style.display = show ? 'block' : 'none';
    inMenu = show;
  }

  backdrop.addEventListener('pointerdown', (e) => {
    e.preventDefault();
    abortDraw = true;
    showMenu(false);
    requestDraw();
  }, { passive: false });

  // ---------- gesture handling ----------
  let inMenu = false;
  let drawing = false;
  let abortDraw = false;

  const LONG_PRESS_MS = 520;
  let pressTimer = null;
  let moved = false;

  function onPressStart() {
    moved = false;
    if (pressTimer) clearTimeout(pressTimer);
    pressTimer = setTimeout(() => {
      pressTimer = null;
      abortDraw = true;
      showMenu(true);
    }, LONG_PRESS_MS);
  }

  function onPressMove() {
    moved = true;
    if (pressTimer) { clearTimeout(pressTimer); pressTimer = null; }
  }

  function onPressEnd() {
    if (!pressTimer) return;
    clearTimeout(pressTimer);
    pressTimer = null;
    if (!moved && !inMenu) requestDraw();
  }

  canvas.addEventListener('pointerdown', onPressStart, { passive: true });
  canvas.addEventListener('pointermove', onPressMove, { passive: true });
  canvas.addEventListener('pointerup', onPressEnd, { passive: true });
  canvas.addEventListener('pointercancel', onPressEnd, { passive: true });
  window.addEventListener('contextmenu', (e) => e.preventDefault());

  // ---------- helpers ----------
  function randUniform(lo, hi) { return lo + Math.random() * (hi - lo); }
  function randInt(lo, hi) { return Math.floor(lo + Math.random() * (hi - lo + 1)); }
  function pick(arr) { return arr[Math.floor(Math.random() * arr.length)]; }

  function setDelta(v) {
    deltaRadios.forEach(r => r.checked = (parseInt(r.value, 10) === v));
  }

  function setRandMode(v) {
    randModeRadios.forEach(r => r.checked = (r.value === v));
  }

  // ---------- dual randomize ----------
  function randomizeAlphaBeta() {
    elAlpha.value = randUniform(-100, 100).toFixed(6);
    elBeta.value = randUniform(-100, 100).toFixed(6);
  }

  function randomizeAllParams() {
    // formula
    elFormula.value = pick(Variants).id;

    // alpha/beta
    randomizeAlphaBeta();

    // gamma (keep moderate most of the time for stability)
    elGamma.value = randUniform(-1.5, 1.5).toFixed(6);

    // delta
    setDelta(Math.random() < 0.5 ? 0 : 1);

    // orbits / iters / burn
    elOrbits.value = String(pick([10, 25, 50, 60]));
    elIters.value  = String(pick([2000, 4000, 8000, 12000, 16000]));
    elBurn.value   = String(pick([0, 20, 50, 100, 200]));

    // range / init range
    elRangeR.value = String(pick([150, 200, 250, 300, 400, 600]));
    elInitR.value  = String(pick([30, 50, 80, 100, 150]));

    // colormap
    elCmap.value = pick(Object.keys(ColorMaps));
  }

  function applyRandomizeModeIfEnabled() {
    if (!elRandomize.checked) return;

    if (getRandMode() === "ab") {
      randomizeAlphaBeta();
    } else {
      randomizeAllParams();
    }
    syncUI();
  }

  // ---------- colormap to orbit colors ----------
  function makeOrbitColors(N, cmapName) {
    const cmap = ColorMaps[cmapName] || ColorMaps["Turbo"];
    const cols = new Array(N);
    if (N <= 1) {
      cols[0] = cmap(0.5).map(x => x|0);
      return cols;
    }
    for (let i=0;i<N;i++){
      const t = i / (N - 1);
      const c = cmap(t);
      cols[i] = [c[0]|0, c[1]|0, c[2]|0];
    }
    return cols;
  }

  // ---------- draw ----------
  function requestDraw() {
    if (drawing || inMenu) return;
    abortDraw = false;
    drawHopalong();
  }

  function drawHopalong() {
    drawing = true;

    // auto randomize (based on mode)
    applyRandomizeModeIfEnabled();

    const a = +elAlpha.value;
    const b = +elBeta.value;
    const g = +elGamma.value;
    const d = getDelta();

    const variant = getVariant();
    const N = parseInt(elOrbits.value, 10);
    const iters = parseInt(elIters.value, 10);
    const burn = parseInt(elBurn.value, 10);
    const r = parseFloat(elRangeR.value);
    const initR = parseFloat(elInitR.value);

    const w = canvas.width, h = canvas.height;
    const sx = (w - 1) / (2 * r);
    const sy = (h - 1) / (2 * r);
    const xoff = r, yoff = r;

    const orbitColors = makeOrbitColors(N, elCmap.value);

    // clear buffer
    for (let i = 0; i < buf.length; i += 4) {
      buf[i] = 0; buf[i+1] = 0; buf[i+2] = 0; buf[i+3] = 255;
    }

    let orbitIdx = 0;

    function stepFrame() {
      if (abortDraw || inMenu) {
        drawing = false;
        ctx.putImageData(img, 0, 0);
        return;
      }

      const orbitsPerFrame = 3;
      let done = 0;

      while (orbitIdx < N && done < orbitsPerFrame) {
        let x = randUniform(-initR, initR);
        let y = randUniform(-initR, initR);

        const col = orbitColors[orbitIdx];
        const rr = col[0], gg = col[1], bb = col[2];

        // burn-in
        for (let k = 0; k < burn; k++) {
          const res = variant.step(x, y, a, b, g, d);
          x = res[0]; y = res[1];
          if (!Number.isFinite(x) || !Number.isFinite(y)) { x = 0; y = 0; break; }
        }

        // plot
        for (let k = burn; k < iters; k++) {
          const res = variant.step(x, y, a, b, g, d);
          x = res[0]; y = res[1];
          if (!Number.isFinite(x) || !Number.isFinite(y)) break;

          const px = ((x + xoff) * sx) | 0;
          const py = ((yoff - y) * sy) | 0;

          if ((px >>> 0) < w && (py >>> 0) < h) {
            setPixel(px, py, rr, gg, bb);
          }

          if ((k & 1023) === 0 && (abortDraw || inMenu)) break;
        }

        orbitIdx++;
        done++;
      }

      ctx.putImageData(img, 0, 0);

      if (orbitIdx < N) requestAnimationFrame(stepFrame);
      else {
        drawing = false;
        ctx.putImageData(img, 0, 0);
      }
    }

    requestAnimationFrame(stepFrame);
  }

  // buttons
  btnApply.addEventListener('click', () => {
    syncUI();
    showMenu(false);
    requestDraw();
  });
  btnClose.addEventListener('click', () => showMenu(false));

  // Start with immediate draw
  setTimeout(() => requestDraw(), 50);

})();
</script>
</body>
</html>